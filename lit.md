###### Usage

Extract this code to a script called `lit`.

```bash
sed -n 's,^	lit: ,,p' lit.md >lit
```

Test the script in the current directory.

	chmod +x lit
	host obsid which lit

This will just error, saying that the variable `lit` is not defined.

	host obsid lit

Print the file as extracted.

	host ./lit 'lit=lit.md' 'file=lit' 'run=cat'

List the available tags to extract from one [[literate program]] file.

	host ./lit 'lit=lit.md'

###### Code

	lit: #!/usr/bin/env bash

	lit: set -eu
	lit: set -o pipefail

	lit: self=$(basename $0)

See [[argenv]].

	lit: for arg in "$@"; do
	lit: 	if echo "$arg" | grep '=' >/dev/null 2>&1; then
	lit: 		arg_name=$(echo $arg | sed 's =.*  ')
	lit: 		arg_value=$(echo $arg | sed 's ^[^=]*=  ')
	lit: 		eval ${arg_name}='${arg_value}'
	lit: 		shift
	lit: 	else
	lit: 		break
	lit: 	fi
	lit: done

	lit: test -n "$lit"

	lit: tag=${tag-}

	lit: file=${file-}
	lit: if test -n "$file"; then
	lit: 	dir=$(dirname $file)

If we have a file and we don't have a tag, expect the file to be the tag.

	lit: 	if test -z "$tag"; then
	lit: 		tag=$file
	lit: 	fi
	lit: 	if ! test -d "$dir"; then
	lit: 		mkdir -p $dir
	lit: 	fi

Extract code lines from the literate program file, and remove the tag.

	lit: 	sed -n "s,^	${tag}: ,,p" $lit >$file

It shouldn't hurt to make the resulting file executable, even if it won't be executed directly.

	lit: 	chmod +x $file

Let the reader know that this file was generated, so should not be edited, since the edits will disappear the next time the file is generated.

	lit: 	nocomment=${nocomment-false}
	lit: 	if ! $nocomment; then
	lit: 		echo "# DO NOT EDIT THIS FILE.  Auto-generated from $lit by $self." >>$file
	lit: 	fi

	lit: 	ext=$(echo $file | sed 's .*\.  ')
	lit: fi

	lit: run=${run-}
	lit: if test -n "$run"; then

Set the tag to the name of the interpreter, without any options after the first whitespace.

	lit: 	tag=${tag:-$(echo $run | sed 's,[	 ].*$,,')}
	lit: 	ext=$tag

If the tag is the name of a language, use the language's usual extension.

	lit: 	case $tag in
	lit: 		perl)
	lit: 			ext=pl
	lit: 			;;
	lit: 		python)
	lit: 			ext=py
	lit: 			;;
	lit: 		ruby)
	lit: 			ext=rb
	lit: 			;;
	lit: 	esac

	lit: 	sed -n "s,^	${tag}: ,,p" $lit >${lit}.${ext}

Run the extracted file with the given interpreter.

	lit: 	$run ${lit}.${ext} "$@"
	lit: fi

If we're not given a tag, list tags available in the given file.

	lit: if test -z "$tag"; then
	lit: 	sed -n 's,^	\([^: ]\+\): .*,\1,p' $lit | sort | uniq
	lit: fi
